# Floating Point Program

This program `floating_point.cpp` simply tests the correctness of the Floating Point Unit of the processor of ZenithSoC. The program takes as input two tables of floating point numbers, then use those to execute the RISC-V floating point instructions, a loop is used to select a precise instruction that is executed for each pair of operands. The results are written in a memory location that is used by the testbench as a print to speedup simulation time (writing to UART would result into a buffer filling thus slowing down the program). 

The program `generator.py` generate the test vectors and create the `operand_1/2.cpp` files that contains the arrays. Another python program, `converter.py` convert a stream of hexadecimal number into floating point numbers, those are written in the folder `ZenithSoC Data`, where a file for each test case is found.

The golden model data (found in the folder Golden Model) is generated by the `result.c` program which output the correct result for each test case.

After the program has been simulated, the script `process_output.sh` must be executed. The user must ensure that the testbench in `Testbench/System/SoC_testbench.sv` has the define `TRACE_OUTPUT` enabled, after the simulation, a file called `output_trace.txt` is created with the data from the CPU. The script divide all the rows in groups of N rows (N is the number of test operands), those groups are put into a file which then is processed by `converter.py`, a diff between the ZenithSoC result and the golden model is then executed. 


# Compilation

To compile, ensure that the script `compile.sh` can be executed, then in the terminal: `./compile.sh`. Change the file paths in `ZenithSoC.sv` in the boot memory (the final output which is boot + program compiled is found in output.hex). If you're using `basic_system.sv` then change the file paths from the main memory (your_abs_path/program.hex) and boot memory (your_abs_path/boot.hex).